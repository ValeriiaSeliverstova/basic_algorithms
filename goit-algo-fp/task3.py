"""
Використання бінарної купи (heapq) для pq дозволяє швидко обирати вершину з найкоротшою відстанню на кожному кроці. Це значно підвищує ефективність алгоритму Дейкстри порівняно з лінійним пошуком
"""


import heapq
import networkx as nx

# Створення графа
G = nx.Graph()

red_line = [
    "Академмістечко", "Житомирська", "Святошин", "Нивки", "Берестейська", "Шулявська", 
    "Політехнічний інститут", "Вокзальна", "Університет", "Театральна", "Хрещатик", 
    "Арсенальна", "Дніпро", "Гідропарк", "Лівобережна", "Дарниця", "Чернігівська", "Лісова"
]

blue_line = [
    "Героїв Дніпра", "Мінська", "Оболонь", "Почайна", "Тараса Шевченка", "Контрактова площа", 
    "Поштова площа", "Майдан Незалежності", "Площа Льва Толстого", "Олімпійська", "Палац Україна", 
    "Либідська", "Деміївська", "Голосіївська", "Васильківська", "Виставковий центр", "Іподром", "Теремки"
]

green_line = [
    "Сирець", "Дорогожичі", "Лук'янівська", "Золоті ворота", "Палац спорту", "Кловська", "Печерська", 
    "Дружби народів", "Видубичі", "Славутич", "Осокорки", "Позняки", "Харківська", "Вирлиця", 
    "Бориспільська", "Червоний хутір"
]

# Додавання вузлів для кожної лінії метро
G.add_nodes_from(red_line)
G.add_nodes_from(blue_line)
G.add_nodes_from(green_line)


# Додавання ребер (зв'язків між станціями) для кожної лінії з вагами
G.add_weighted_edges_from([
    ("Академмістечко", "Житомирська", 5), 
    ("Житомирська", "Святошин", 3), 
    ("Святошин", "Нивки", 2), 
    ("Нивки", "Берестейська", 4), 
    ("Берестейська", "Шулявська", 3), 
    ("Шулявська", "Політехнічний інститут", 2),
    ("Політехнічний інститут", "Вокзальна", 3), 
    ("Вокзальна", "Університет", 1), 
    ("Університет", "Театральна", 2),
    ("Театральна", "Хрещатик", 1), 
    ("Хрещатик", "Арсенальна", 2), 
    ("Арсенальна", "Дніпро", 1),
    ("Дніпро", "Гідропарк", 2), 
    ("Гідропарк", "Лівобережна", 4), 
    ("Лівобережна", "Дарниця", 3),
    ("Дарниця", "Чернігівська", 4), 
    ("Чернігівська", "Лісова", 5)
])

G.add_weighted_edges_from([
    ("Героїв Дніпра", "Мінська", 4), 
    ("Мінська", "Оболонь", 3), 
    ("Оболонь", "Почайна", 2),
    ("Почайна", "Тараса Шевченка", 4), 
    ("Тараса Шевченка", "Контрактова площа", 3), 
    ("Контрактова площа", "Поштова площа", 2), 
    ("Поштова площа", "Майдан Незалежності", 1),
    ("Майдан Незалежності", "Площа Льва Толстого", 1), 
    ("Площа Льва Толстого", "Олімпійська", 2),
    ("Олімпійська", "Палац Україна", 2), 
    ("Палац Україна", "Либідська", 3), 
    ("Либідська", "Деміївська", 2),
    ("Деміївська", "Голосіївська", 4), 
    ("Голосіївська", "Васильківська", 3), 
    ("Васильківська", "Виставковий центр", 2), 
    ("Виставковий центр", "Іподром", 3), 
    ("Іподром", "Теремки", 4)
])

G.add_weighted_edges_from([
    ("Сирець", "Дорогожичі", 3), 
    ("Дорогожичі", "Лук'янівська", 2), 
    ("Лук'янівська", "Золоті ворота", 3),
    ("Золоті ворота", "Палац спорту", 1), 
    ("Палац спорту", "Кловська", 2), 
    ("Кловська", "Печерська", 3), 
    ("Печерська", "Дружби народів", 4), 
    ("Дружби народів", "Видубичі", 3), 
    ("Видубичі", "Славутич", 2),
    ("Славутич", "Осокорки", 2), 
    ("Осокорки", "Позняки", 3), 
    ("Позняки", "Харківська", 4), 
    ("Харківська", "Вирлиця", 2), 
    ("Вирлиця", "Бориспільська", 3), 
    ("Бориспільська", "Червоний хутір", 5)
])

# Додавання пересадок з вагами
G.add_weighted_edges_from([
    ("Хрещатик", "Майдан Незалежності", 1),  #вага пересадки між Хрещатик і Майдан Незалежності
    ("Театральна", "Золоті ворота", 1)  # Вага пересадки між Театральна і Золоті ворота
])

# Реалізація алгоритму Дейкстри
def dijkstra(graph, start):
    shortest_paths = {vertex: float('infinity') for vertex in graph}
    shortest_paths[start] = 0
    pq = [(0, start)]
    
    while pq:
        print("pq:", pq)
        print("sp:", shortest_paths)
        current_distance, current_vertex = heapq.heappop(pq)
        
        for neighbor, attributes in graph[current_vertex].items():
            weight = attributes['weight']  # Отримуємо вагу з атрибутів
            distance = current_distance + weight
            if distance < shortest_paths[neighbor]:
                shortest_paths[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
                print(f"Найкоротший шлях від станції {start} до станції {neighbor}: {distance}")
                print("-------------------------------------------------------------------------------------------------------------------------------------------------------------")
    
    return shortest_paths

shortest_paths = dijkstra(G, "Академмістечко")
print(shortest_paths)
